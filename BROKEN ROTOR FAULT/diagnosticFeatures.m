function [featureTable,ensembleStatistics,outputEnsemble] = diagnosticFeatures(inputEnsemble)
%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputEnsemble: A file ensemble datastore containing the
%  data as those imported into the app.
%
% Output:
%  featureTable: A table containing all features and condition variables.
%  ensembleStatistics: A table containing ensemble statistics.
%  outputEnsemble: A workspace ensemble object containing the computation results.
%
% This function computes signals:
%  Vib_acpi_env_interp/Data
%  Vib_acpi_env_mean/Data
%  Vib_acpi_env_res/Data
%  Vib_acpi_env_tsproc/Data
%
% This function computes spectra:
%  Vib_acpi_env_ps/SpectrumData
%
% This function computes features:
%  Vib_acpi_env_ps_spec/BandPower
%  Vib_acpi_env_tsproc_tsfeat/Minimum
%  Vib_acpi_env_tsproc_tsfeat/Q1
%  Vib_acpi_env_tsproc_tsfeat/Q3
%  Vib_acpi_env_tsproc_tsfeat/IQR
%  Vib_acpi_env_res_sigstats/Mean
%  Vib_acpi_env_res_tsfeat/Median
%  Vib_acpi_env_res_tsfeat/Q3
%  Vib_acpi_env_res_tsfeat/IQR
%  Vib_acpi_env_sigstats/Mean
%  Vib_acpi_env_tsfeat/Median
%  Vib_acpi_env_tsfeat/Q3
%  Vib_acpi_env_tsfeat/IQR
%  Ia_env_ps_fault/PeakAmp3
%  Ia_env_ps_fault/PeakAmp4
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 12-Dec-2023 23:25:47

% Configure input ensemble
inputEnsemble.DataVariables = ["Vib_acpi_env";"Ia_env_ps"];
inputEnsemble.ConditionVariables = "Health";

% Initialize ensemble statistics.
ensembleStatistics = table;

% Reset the ensemble to read from the beginning of the ensemble.
reset(inputEnsemble);

% Set SelectedVariables to select variables to read from the ensemble.
inputEnsemble.SelectedVariables = ["Vib_acpi_env","Ia_env_ps"];

% Create output ensemble.
outputEnsemble = workspaceEnsemble('DataVariables',"File");

% Append new signal or feature names to DataVariables.
outputEnsemble.DataVariables = unique([outputEnsemble.DataVariables;"Vib_acpi_env_interp";"Vib_acpi_env_tsproc";"Vib_acpi_env_ps";"Vib_acpi_env_ps_spec";"Vib_acpi_env_tsproc_tsfeat";"Vib_acpi_env_sigstats";"Vib_acpi_env_tsfeat";"Ia_env_ps_fault"],'stable');

% Compute sampling frequency for interpolation.
member1 = read(inputEnsemble);

time = readMemberData(member1,"Vib_acpi_env/Time");
time = time2num(time,"seconds");
Vib_acpi_env_interp_Fs = effectivefs(time);
reset(inputEnsemble)

% Initialize a table to store accumulated results.
accumulator = table;

% Loop through all ensemble members to read and write data.
while hasdata(inputEnsemble)
    % Read one member.
    member = read(inputEnsemble);

    % Get file name of the last read member.
    fileName = inputEnsemble.LastMemberRead;

    % Find index for reading or writing an output ensemble member.
    idx = findIndex(outputEnsemble,'File',fileName);

    % Update accumulator.
    if isempty(accumulator)
        accumulator.Vib_acpi_env_interp = {table};
        accumulator.Properties.UserData = [ ...
            ["Vib_acpi_env_interp"; "Vib_acpi_env_mean"]];
    end

    % Get all input variables.
    Vib_acpi_env = readMemberData(member,"Vib_acpi_env",["Time","Data"]);
    Ia_env_ps = readMemberData(member,"Ia_env_ps");

    % Initialize a table to store results.
    memberResult = table(fileName,'VariableNames',"File");

    %% Interpolation
    try
        % Compute interpolation
        time = Vib_acpi_env.Time;

        % Get sampling period
        samplePeriod_numeric = 1/Vib_acpi_env_interp_Fs;
        if isduration(time) || isdatetime(time)
            samplePeriod = seconds(samplePeriod_numeric);
        else
            samplePeriod = samplePeriod_numeric;
        end

        if isdatetime(time)
            timeOrigin = datetime(0,1,1,0,0,0);
            ivStart = min(time) - timeOrigin;
            ivEnd = max(time) - timeOrigin;
        else
            ivStart = min(time);
            ivEnd = max(time);
        end

        gridStartIdx = ceil(ivStart/samplePeriod);
        gridEndIdx = floor(ivEnd/samplePeriod);

        ivGrid = (gridStartIdx:gridEndIdx)'*samplePeriod;
        if isdatetime(time)
            ivGrid = ivGrid + timeOrigin;
        end

        % Interpolation
        val = interp1(time,Vib_acpi_env.Data,ivGrid,'linear',NaN);
        Vib_acpi_env_interp = table(ivGrid,val,'VariableNames',{'Time','Data'});
    catch
        % Package computed signal into a table.
        Vib_acpi_env_interp = table(NaN,NaN,'VariableNames',{'Time','Data'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_interp},'VariableNames',{'Vib_acpi_env_interp'})]; %#ok<AGROW>

    %% EnsembleStatistics
    try
        newData = Vib_acpi_env_interp;
        % Get new info
        newIV = newData.Time;
        newDV = newData.Data;

        %% Get accumulator
        accumData = accumulator.Vib_acpi_env_interp{1};

        % Update accumulator sum and count with current data.
        newCount = double(~isnan(newDV));
        if isempty(accumData)
            accumData = table(newIV, newDV, newCount, 'VariableNames', ["IV","Sum","Count"]);
        else
            accumIV = accumData.IV;
            [~, idxAccum, idxNewData] = intersect(accumIV, newIV);

            accumData.Sum(idxAccum) = sum([accumData.Sum(idxAccum),newDV(idxNewData)],2,'omitnan');
            accumData.Count(idxAccum) = accumData.Count(idxAccum) + newCount(idxNewData);

            % Find the non-overlapping indices
            if~isempty(newIV) && ~isdatetime(newIV(1)) && all(isnan(newIV))
                idxTblComp = false;
            else
                idxTblComp = true(size(newIV));
                idxTblComp(idxNewData) = false;
            end
            if any(idxTblComp)
                count = ones(sum(idxTblComp), 1);
                tbl2merge = table(newIV(idxTblComp),newDV(idxTblComp),count,'VariableNames',["IV","Sum","Count"]);
                accumData = outerjoin(accumData, tbl2merge,'Keys',["IV","Sum","Count"],'MergeKeys', true);
            end
        end

        % Save updated accumulated data back to the accumulator.
        accumulator.Vib_acpi_env_interp = {accumData};
    catch
        % Package computed signal into a table.
        accumData = array2table(NaN(1,3),'VariableNames',["IV", "Count", "Sum"]);
        accumulator.Vib_acpi_env_interp = {accumData};
    end

    %% TimeSeriesProcessing
    try
        % Apply time series processing steps.
        x = Vib_acpi_env.Data;
        t = Vib_acpi_env.Time;
        % Detrend the signal.
        order = 1;
        x = detrend(x, order, 'omitnan', 'SamplePoints', t);

        % Package computed signal into a table.
        Vib_acpi_env_tsproc = table(t,x,'VariableNames',{'Time','Data'});
    catch
        % Package computed signal into a table.
        data = NaN(1,2);
        Vib_acpi_env_tsproc = array2table(data,'VariableNames',{'Time','Data'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_tsproc},'VariableNames',{'Vib_acpi_env_tsproc'})]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";

        % Compute effective sampling rate.
        tNumeric = time2num(Vib_acpi_env.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x_raw = Vib_acpi_env.Data;
        if irregular
            x = resample(x_raw,tNumeric,Fs,'linear');
        else
            x = x_raw;
        end

        % Set Welch spectrum parameters.
        L = fix(length(x)/4.5);
        noverlap = fix(L*50/100);
        win = hamming(L);

        % Compute the power spectrum.
        [ps,f] = pwelch(x,win,noverlap,[],Fs);
        w = 2*pi*f;

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
        ps.Properties.VariableUnits = {'Hz', ''};
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        Vib_acpi_env_ps = ps;
    catch
        Vib_acpi_env_ps = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_ps},'VariableNames',{'Vib_acpi_env_ps'})]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = Vib_acpi_env_ps.SpectrumData;
        w = Vib_acpi_env_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0) & (w<=factor*3800);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = BandPower;

        % Package computed features into a table.
        featureNames = {'BandPower'};
        Vib_acpi_env_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,1);
        featureNames = {'BandPower'};
        Vib_acpi_env_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_ps_spec},'VariableNames',{'Vib_acpi_env_ps_spec'})]; %#ok<AGROW>

    %% TimeSeriesFeatures
    try
        % Compute time series features.
        inputSignal = Vib_acpi_env_tsproc.Data;
        quartiles = quantile(inputSignal, [0.25 0.5 0.75]);

        % Extract individual feature values.
        Minimum = min(inputSignal);
        Q1 = quartiles(1);
        Q3 = quartiles(3);
        IQR = quartiles(3)-quartiles(1);

        % Concatenate signal features.
        featureValues = [Minimum,Q1,Q3,IQR];

        % Package computed features into a table.
        featureNames = {'Minimum','Q1','Q3','IQR'};
        Vib_acpi_env_tsproc_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,4);
        featureNames = {'Minimum','Q1','Q3','IQR'};
        Vib_acpi_env_tsproc_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_tsproc_tsfeat},'VariableNames',{'Vib_acpi_env_tsproc_tsfeat'})]; %#ok<AGROW>

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = Vib_acpi_env.Data;
        Mean = mean(inputSignal,'omitnan');

        % Concatenate signal features.
        featureValues = Mean;

        % Package computed features into a table.
        featureNames = {'Mean'};
        Vib_acpi_env_sigstats = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,1);
        featureNames = {'Mean'};
        Vib_acpi_env_sigstats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_sigstats},'VariableNames',{'Vib_acpi_env_sigstats'})]; %#ok<AGROW>

    %% TimeSeriesFeatures
    try
        % Compute time series features.
        inputSignal = Vib_acpi_env.Data;
        quartiles = quantile(inputSignal, [0.25 0.5 0.75]);

        % Extract individual feature values.
        Median = median(inputSignal, 'omitnan');
        Q3 = quartiles(3);
        IQR = quartiles(3)-quartiles(1);

        % Concatenate signal features.
        featureValues = [Median,Q3,IQR];

        % Package computed features into a table.
        featureNames = {'Median','Q3','IQR'};
        Vib_acpi_env_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = {'Median','Q3','IQR'};
        Vib_acpi_env_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_tsfeat},'VariableNames',{'Vib_acpi_env_tsfeat'})]; %#ok<AGROW>

    %% CustomFaultsFeatures
    try
        % Compute the fault frequency bands.
        [FB, info] = faultBands(60, [1 2 3 4 5 6], 30, [0 1], 'Width', 10, 'Folding', true);

        % Compute spectral fault band metrics.
        sd = Ia_env_ps.Col2;
        w = Ia_env_ps.Col1;

        metrics = faultBandMetrics(sd, w, FB(1:18,:));

        % Extract computed features.
        metricsNames = {'PeakAmplitude3','PeakAmplitude4'};
        featureNames = {'PeakAmp3','PeakAmp4'};
        Ia_env_ps_fault = metrics(:,metricsNames);
        Ia_env_ps_fault = renamevars(Ia_env_ps_fault, metricsNames, featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,2);
        featureNames = ["PeakAmp3","PeakAmp4"];
        Ia_env_ps_fault = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Ia_env_ps_fault},'VariableNames',{'Ia_env_ps_fault'})]; %#ok<AGROW>

    %% Write all the results for the current member to the ensemble.
    writeMember(outputEnsemble,memberResult,idx);
end

% Compute reduce results
allNames = accumulator.Properties.UserData;
% Reduce ensemble mean
for idx = find(contains(allNames(2,:),"mean"))
    accumData = accumulator.(allNames(1,idx)){1};
    ensembleMean = accumData.Sum./accumData.Count;
    ensembleStatistics.(allNames(2,idx)) = {table(accumData.IV,ensembleMean,'VariableNames',["Time","Data"])};
end

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new signal or feature names to DataVariables.
outputEnsemble.DataVariables = unique([outputEnsemble.DataVariables;"Vib_acpi_env_res";"Vib_acpi_env_res_sigstats";"Vib_acpi_env_res_tsfeat"],'stable');

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = "Vib_acpi_env_interp";

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    inMemMember = read(outputEnsemble);

    % Get all input variables.
    Vib_acpi_env_interp = readMemberData(inMemMember,"Vib_acpi_env_interp",["Time","Data"]);
    Vib_acpi_env_mean = readMemberData(ensembleStatistics,"Vib_acpi_env_mean",["Time","Data"]);

    % Initialize a table to store results.
    memberResult = table;

    %% SubtractReference
    try
        % Subtract reference from input signal.
        [~, SRidx] = intersect(Vib_acpi_env_interp.Time, Vib_acpi_env_mean.Time);
        difference = Vib_acpi_env_interp.Data - Vib_acpi_env_mean.Data(SRidx);

        % Package computed signal into a table.
        Vib_acpi_env_res = table(Vib_acpi_env_interp.Time, difference, 'VariableNames', {'Time', 'Data'});
    catch
        % Package computed signal into a table.
        Vib_acpi_env_res = array2table(NaN(1,2),'VariableNames',{'Time','Data'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_res},'VariableNames',{'Vib_acpi_env_res'})]; %#ok<AGROW>

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = Vib_acpi_env_res.Data;
        Mean = mean(inputSignal,'omitnan');

        % Concatenate signal features.
        featureValues = Mean;

        % Package computed features into a table.
        featureNames = {'Mean'};
        Vib_acpi_env_res_sigstats = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,1);
        featureNames = {'Mean'};
        Vib_acpi_env_res_sigstats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_res_sigstats},'VariableNames',{'Vib_acpi_env_res_sigstats'})]; %#ok<AGROW>

    %% TimeSeriesFeatures
    try
        % Compute time series features.
        inputSignal = Vib_acpi_env_res.Data;
        quartiles = quantile(inputSignal, [0.25 0.5 0.75]);

        % Extract individual feature values.
        Median = median(inputSignal, 'omitnan');
        Q3 = quartiles(3);
        IQR = quartiles(3)-quartiles(1);

        % Concatenate signal features.
        featureValues = [Median,Q3,IQR];

        % Package computed features into a table.
        featureNames = {'Median','Q3','IQR'};
        Vib_acpi_env_res_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = {'Median','Q3','IQR'};
        Vib_acpi_env_res_tsfeat = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({Vib_acpi_env_res_tsfeat},'VariableNames',{'Vib_acpi_env_res_tsfeat'})]; %#ok<AGROW>

    %% Write all the results for the current member to the ensemble.
    writeToLastMemberRead(outputEnsemble,memberResult);
end

% Gather all features into a table.
selectedFeatureNames = ["Vib_acpi_env_ps_spec/BandPower","Vib_acpi_env_tsproc_tsfeat/Minimum","Vib_acpi_env_tsproc_tsfeat/Q1","Vib_acpi_env_tsproc_tsfeat/Q3","Vib_acpi_env_tsproc_tsfeat/IQR","Vib_acpi_env_res_sigstats/Mean","Vib_acpi_env_res_tsfeat/Median","Vib_acpi_env_res_tsfeat/Q3","Vib_acpi_env_res_tsfeat/IQR","Vib_acpi_env_sigstats/Mean","Vib_acpi_env_tsfeat/Median","Vib_acpi_env_tsfeat/Q3","Vib_acpi_env_tsfeat/IQR","Ia_env_ps_fault/PeakAmp3","Ia_env_ps_fault/PeakAmp4"];
featureTable = readFeatureTable(outputEnsemble,'Features',selectedFeatureNames);

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = unique([outputEnsemble.DataVariables;outputEnsemble.ConditionVariables;outputEnsemble.IndependentVariables],'stable');
end
